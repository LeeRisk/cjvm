#ifndef MOON_INS_STACK_H
#define MOON_INS_STACK_H

// 栈
// POP 87     0x57 将栈顶数值弹出（数值不能是long或double类型的）
// POP2 88    0x58 将栈顶的一个（long或double类型的）或两个数值弹出（其它）
// DUP 89     0x59 复制栈顶数值并将复制值压入栈顶
// DUP_X1 90  0x5a 复制栈顶数值并将两个复制值压入栈顶
// DUP_X2 91  0x5b 复制栈顶数值并将三个（或两个）复制值压入栈顶
// DUP2 92    0x5c 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶
// DUP2_X1 93 0x5d dup_x1指令的双倍版本
// DUP2_X2 94 0x5e dup_x2指令的双倍版本
// SWAP 95    0x5f 将栈最顶端的两个数值互换（数值不能是long或double类型的）
// 数学
// IADD 96   0x60 将栈顶两int型数值相加并将结果压入栈顶
// LADD 97   0x61 将栈顶两long型数值相加并将结果压入栈顶
// FADD 98   0x62 将栈顶两float型数值相加并将结果压入栈顶
// DADD 99   0x63 将栈顶两double型数值相加并将结果压入栈顶
// ISUB 100  0x64 将栈顶两int型数值相减并将结果压入栈顶
// LSUB 101  0x65 将栈顶两long型数值相减并将结果压入栈顶
// FSUB 102  0x66 将栈顶两float型数值相减并将结果压入栈顶
// DSUB 103  0x67 将栈顶两double型数值相减并将结果压入栈顶
// IMUL 104  0x68 将栈顶两int型数值相乘并将结果压入栈顶
// LMUL 105  0x69 将栈顶两long型数值相乘并将结果压入栈顶
// FMUL 106  0x6a 将栈顶两float型数值相乘并将结果压入栈顶
// DMUL 107  0x6b 将栈顶两double型数值相乘并将结果压入栈顶
// IDIV 108  0x6c 将栈顶两int型数值相除并将结果压入栈顶
// LDIV 109  0x6d 将栈顶两long型数值相除并将结果压入栈顶
// FDIV 110  0x6e 将栈顶两float型数值相除并将结果压入栈顶
// DDIV 111  0x6f 将栈顶两double型数值相除并将结果压入栈顶
// IREM 112  0x70 将栈顶两int型数值作取模运算并将结果压入栈顶
// LREM 113  0x71 将栈顶两long型数值作取模运算并将结果压入栈顶
// FREM 114  0x72 将栈顶两float型数值作取模运算并将结果压入栈顶
// DREM 115  0x73 将栈顶两double型数值作取模运算并将结果压入栈顶
// INEG 116  0x74 将栈顶int型数值取负并将结果压入栈顶
// LNEG 117  0x75 将栈顶long型数值取负并将结果压入栈顶
// FNEG 118  0x76 将栈顶float型数值取负并将结果压入栈顶
// DNEG 119  0x77 将栈顶double型数值取负并将结果压入栈顶
// ISHL 120  0x78 将int型数值左移位指定位数并将结果压入栈顶
// LSHL 121  0x79 将long型数值左移位指定位数并将结果压入栈顶
// ISHR 122  0x7a 将int型数值右（有符号）移位指定位数并将结果压入栈顶
// LSHR 123  0x7b 将long型数值右（有符号）移位指定位数并将结果压入栈顶
// IUSHR 124 0x7c 将int型数值右（无符号）移位指定位数并将结果压入栈顶
// LUSHR 125 0x7d 将long型数值右（无符号）移位指定位数并将结果压入栈顶
// IAND 126  0x7e 将栈顶两int型数值作“按位与”并将结果压入栈顶
// LAND 127  0x7f 将栈顶两long型数值作“按位与”并将结果压入栈顶
// IOR 128   0x80 将栈顶两int型数值作“按位或”并将结果压入栈顶
// LOR 129   0x81 将栈顶两long型数值作“按位或”并将结果压入栈顶
// IXOR 130  0x82 将栈顶两int型数值作“按位异或”并将结果压入栈顶
// LXOR 131  0x83 将栈顶两long型数值作“按位异或”并将结果压入栈顶
// IINC 132  0x84 将指定int型变量增加指定值

#endif
